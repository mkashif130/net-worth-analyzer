<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portfolio Concentration • Pie</title>
  <style>
    :root{ --bg:#ffffff; --ink:#0b1220; --muted:#6b7280; --ring:#e5e7eb; --accent:#2563eb; --radius:16px; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--ink)}
    .wrap{max-width:1000px;margin:24px auto;padding:12px;display:grid;gap:16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{font-size:18px;margin:0;letter-spacing:.2px;font-weight:700}
    .card{background:#fff;border:1px solid var(--ring);border-radius:var(--radius);padding:14px;box-shadow:0 8px 24px rgba(2,6,23,.04)}
    .row{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:960px){.row{grid-template-columns:1.2fr 1fr}}
    input[type=text]{width:100%;background:#ffffff;border:1px solid #d1d5db;color:var(--ink);border-radius:12px;padding:10px 12px;outline:none;transition:border-color .15s ease}
    input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,.15)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px 8px;text-align:left}
    th{font-weight:600;color:#111827;font-size:12px;letter-spacing:.3px}
    tr{border-bottom:1px dashed #e5e7eb}
    tr:last-child{border-bottom:none}
    .mono{font-variant-numeric:tabular-nums;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ghost-btn{background:#ffffff;border:1px solid #d1d5db;color:#111827;border-radius:12px;padding:8px 10px;cursor:pointer;font-weight:600;font-size:13px}
    .ghost-btn:hover{border-color:var(--accent);color:#0b1220}
    .icon-btn{background:transparent;border:none;color:#6b7280;cursor:pointer;padding:6px;border-radius:8px}
    .icon-btn:hover{background:#f3f4f6;color:#111827}
    .muted{color:var(--muted);font-size:12px}

    /* Chart */
    .chart-col{display:grid;gap:12px}
    canvas{width:100%;height:420px;display:block}

    /* Sticky total */
    .totalbar{position:sticky;bottom:0;background:#fff;border:1px solid var(--ring);border-radius:12px;padding:10px 12px;display:flex;justify-content:space-between;align-items:center;box-shadow:0 -6px 18px rgba(2,6,23,.05)}

    /* Summary (hidden until data present) */
    .pill{border:1px solid var(--ring);padding:4px 8px;border-radius:999px;font-size:12px;font-weight:600}
    .pill.low{background:#ecfdf5;color:#065f46;border-color:#a7f3d0}
    .pill.balanced{background:#eff6ff;color:#1e3a8a;border-color:#bfdbfe}
    .pill.high{background:#fef2f2;color:#991b1b;border-color:#fecaca}
    .summary-list{list-style:none;margin:8px 0 0 0;padding:0;display:grid;gap:8px}
    .summary-list li{font-size:13px;color:#111827;line-height:1.35}
    .summary-list li .tag{font-size:11px;opacity:.7;margin-left:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Portfolio Concentration</h1>
      <div class="muted">Enter amounts only (no %). The pie and total update automatically. Labels are outside with leader lines and basic collision-avoidance.</div>
    </header>

    <section class="card row">
      <div class="left">
        <div class="card" style="padding:0; border-radius:12px;">
          <table>
            <thead>
              <tr>
                <th style="width:60%">Category</th>
                <th style="width:30%">Amount</th>
                <th style="width:10%"></th>
              </tr>
            </thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
        <div style="display:flex; gap:8px; margin-top:10px; align-items:center;">
          <button id="add" class="ghost-btn">+ Add Category</button>
          <div id="note" class="muted"></div>
        </div>
      </div>

      <div class="chart-col">
        <canvas id="pie" width="700" height="700" aria-label="Portfolio pie chart"></canvas>

        <!-- Summary: hidden initially; appears once user adds any positive amounts -->
        <div class="card" id="summaryCard" style="display:none">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
            <h2 style="margin:0;font-size:14px">Summary</h2>
            <span id="riskPill" class="pill">—</span>
          </div>
          <ul id="summaryList" class="summary-list"></ul>
        </div>
      </div>
    </section>

    <div class="totalbar">
      <div class="muted">Total Portfolio</div>
      <div class="mono" id="totalOut">0</div>
    </div>
  </div>

  <script>
    // --- Utilities ---
    const byId = (id) => document.getElementById(id);
    const fmt = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
    const moneyFmt = (n) => (isFinite(n) ? fmt.format(n) : "—");
    const parseAmount = (str) => {
      if (typeof str !== 'string') return 0;
      const clean = str.replace(/[\,\s]/g,'');
      const num = Number(clean);
      return isFinite(num) && num > 0 ? num : 0;
    };
    const hsl = (i,n)=>`hsl(${(i*360/Math.max(1,n))%360} 70% 50%)`;

    // --- Elements ---
    const rowsEl = byId('rows');
    const addBtn = byId('add');
    const noteEl = byId('note');
    const pie = byId('pie');
    const totalOut = byId('totalOut');
    const summaryCard = byId('summaryCard');
    const summaryList = byId('summaryList');
    const riskPill = byId('riskPill');

    // --- Rows ---
    function newRow(category='', value=''){
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td><input type="text" placeholder="e.g., Stocks" value="${category}"/></td>
        <td><input type="text" class="mono" placeholder="e.g., 50000" value="${value}"/></td>
        <td style="text-align:right"><button class="icon-btn" title="Remove" aria-label="Remove">✕</button></td>`;
      rowsEl.appendChild(tr);
    }
    function seed(){ newRow('Stocks',''); newRow('Real Estate',''); newRow('Cash',''); newRow('Crypto',''); }

    function getModel(){
      const items=[];
      [...rowsEl.querySelectorAll('tr')].forEach((tr,idx)=>{
        const name = tr.querySelector('td:nth-child(1) input').value.trim() || `Category ${idx+1}`;
        const raw  = tr.querySelector('td:nth-child(2) input').value;
        const amount = parseAmount(raw);
        if(amount>0) items.push({name,amount});
      });
      const total = items.reduce((a,b)=>a+b.amount,0);
      return { total, items };
    }

    // --- Chart with outside labels & collision avoidance ---
    function draw(model){
      const ctx = pie.getContext('2d');
      const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const W = pie.clientWidth * DPR, H = pie.clientHeight * DPR;
      if(pie.width!==W) pie.width=W; if(pie.height!==H) pie.height=H;
      ctx.clearRect(0,0,W,H); ctx.save();

      const {items,total:sum} = model;
      totalOut.textContent = moneyFmt(sum);

      if(sum<=0){
        ctx.fillStyle = '#9ca3af';
        ctx.font = `${Math.max(14,Math.min(W,H)*0.04)}px ui-sans-serif, system-ui`;
        ctx.textAlign = 'center';
        ctx.fillText('Add category amounts to see the pie', W/2, H/2);
        ctx.restore();
        if(summaryCard) summaryCard.style.display='none';
        return;
      }

      const pad = Math.min(W,H)*0.08;
      const cx = W/2, cy = H/2;
      const radius = Math.max(40, Math.min(W,H)*0.40 - pad);
      const inner  = radius * 0.55;

      const dividerColor = 'rgba(255,255,255,0.95)';
      const leaderColor  = 'rgba(0,0,0,0.45)';
      const labelColor   = '#111827';

      // --- First pass: draw slices and collect label targets
      let start = -Math.PI/2;
      const labels = [];
      items.forEach((it,i)=>{
        const frac = it.amount / sum;
        const end = start + frac*Math.PI*2;

        // slice (donut)
        ctx.beginPath();
        ctx.arc(cx, cy, radius, start, end);
        ctx.arc(cx, cy, inner, end, start, true);
        ctx.closePath();
        ctx.fillStyle = hsl(i, items.length);
        ctx.fill();

        // divider
        ctx.lineWidth = Math.max(1, Math.min(W,H)*0.004);
        ctx.strokeStyle = dividerColor;
        ctx.stroke();

        // label anchor just outside arc
        const mid = (start+end)/2;
        const baseR = radius + 22; // where text baseline aims
        const lx = cx + Math.cos(mid) * baseR;
        const ly = cy + Math.sin(mid) * baseR;
        const side = (mid>Math.PI/2 || mid<-Math.PI/2) ? 'left' : 'right';
        const text = `${it.name} · ${(frac*100).toFixed(frac<0.1?1:0)}%`;
        const angle = mid; // keep for sorting
        labels.push({x:lx,y:ly,side,text,angle,frac});

        start = end;
      });

      // --- Second pass: simple collision avoidance per side ---
      const minGap = Math.max(12, Math.min(W,H)*0.03); // minimum vertical gap between labels
      function relax(side){
        const arr = labels.filter(l=>l.side===side).sort((a,b)=>a.y-b.y);
        for(let i=1;i<arr.length;i++){
          if(arr[i].y - arr[i-1].y < minGap){
            arr[i].y = arr[i-1].y + minGap;
          }
        }
        // also prevent labels from going too far beyond canvas
        const topBound = cy - (radius + 60);
        const botBound = cy + (radius + 60);
        if(arr.length){
          if(arr[0].y < topBound){
            const delta = topBound - arr[0].y;
            for(const l of arr) l.y += delta;
          }
          if(arr[arr.length-1].y > botBound){
            const delta = arr[arr.length-1].y - botBound;
            for(const l of arr) l.y -= delta;
          }
        }
      }
      relax('left');
      relax('right');

      // --- Draw leaders and labels ---
      ctx.font = `${Math.max(11,Math.min(W,H)*0.025)}px ui-sans-serif, system-ui`;
      ctx.textBaseline = 'middle';
      ctx.fillStyle = labelColor;
      labels.forEach(l=>{
        const alignRight = l.side==='left';
        ctx.textAlign = alignRight ? 'right' : 'left';
        const textX = l.x + (alignRight ? -6 : 6);
        const textY = l.y;

        // leader from arc edge to label point, with a small horizontal segment
        const arcPointX = cx + Math.cos(l.angle) * radius;
        const arcPointY = cy + Math.sin(l.angle) * radius;
        const midX = cx + Math.cos(l.angle) * (radius + 10);
        const midY = cy + Math.sin(l.angle) * (radius + 10);
        const endX = textX + (alignRight ? 4 : -4); // small offset before text

        ctx.beginPath();
        ctx.moveTo(arcPointX, arcPointY);
        ctx.lineTo(midX, midY);
        ctx.lineTo(endX, textY);
        ctx.lineWidth = 1;
        ctx.strokeStyle = leaderColor;
        ctx.stroke();

        ctx.fillText(l.text, textX, textY);
      });

      // center total label
      ctx.fillStyle = '#111827';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.max(12,Math.min(W,H)*0.035)}px ui-sans-serif, system-ui`;
      ctx.fillText(`Total ${moneyFmt(sum)}`, cx, cy);

      ctx.restore();
    }

    // --- Summary/advice logic ---
    function classify(name){
      const n = name.toLowerCase();
      if(/bond|fixed|income|treasury|t-bill/.test(n)) return 'bonds';
      if(/stock|equit|etf|fund|voo|qqq|schd|s&p|nasdaq/.test(n)) return 'stocks';
      if(/real\s*estate|property|reit|house|apartment|land/.test(n)) return 'real_estate';
      if(/cash|savings|deposit|money\s*market/.test(n)) return 'cash';
      if(/crypto|bitcoin|btc|eth|sol|token/.test(n)) return 'crypto';
      if(/gold|silver|metal|commodity|oil|energy/.test(n)) return 'commodities';
      return 'other';
    }

    function analyze(model){
      const total = model.total || 0;
      const buckets = {};
      model.items.forEach(it=>{ const k = classify(it.name); buckets[k]=(buckets[k]||0)+it.amount; });
      const pct = k => total>0 ? (buckets[k]||0)/total : 0;
      const p = { stocks:pct('stocks'), bonds:pct('bonds'), cash:pct('cash'), real_estate:pct('real_estate'), crypto:pct('crypto'), commodities:pct('commodities'), other:pct('other') };

      let risk = 'balanced';
      const growth = p.stocks + p.crypto + p.commodities*0.5;
      const defense = p.bonds + p.cash + p.real_estate*0.2;
      if(growth >= 0.7 || p.crypto >= 0.12) risk = 'high';
      else if(defense >= 0.45 || p.bonds >= 0.35) risk = 'low';

      const out = [];
      const add = (msg, tag='tip') => out.push({msg, tag});

      const totalItems = model.items.length;
      if(totalItems){
        const top = [...model.items].sort((a,b)=>b.amount-a.amount)[0];
        if(top && total>0 && top.amount/total > 0.6) add('High concentration: "'+top.name+'" is '+(top.amount/total*100).toFixed(0)+'% of the portfolio.', 'concentration');
      }
      if(p.stocks > 0.7) add('Equities >70% → growth-tilted/volatile. Consider adding bonds or cash-like assets.', 'equities');
      if(p.bonds < 0.1) add('Bonds <10% → weak downside protection. Build bonds/treasuries toward 15–30%.', 'bonds');
      if(p.cash > 0.35) add('Cash >35% → return drag. Consider deploying into long-term targets or a T‑bill ladder.', 'cash');
      if(p.real_estate > 0.5) add('Real estate >50% → liquidity risk. Balance with liquid funds.', 'real-estate');
      if(p.crypto > 0.1) add('Crypto >10% → very volatile. Consider sizing to ≤5–10% unless high tolerance.', 'crypto');
      if(totalItems < 4) add('Diversify across at least 4–6 categories to reduce idiosyncratic risk.', 'diversify');

      return { risk, tips: out };
    }

    function renderSummary(model){
      if(!summaryCard) return;
      if(!model.total){ summaryCard.style.display='none'; return; }
      summaryCard.style.display='block';
      const adv = analyze(model);
      riskPill.className = 'pill ' + adv.risk;
      riskPill.textContent = adv.risk.charAt(0).toUpperCase() + adv.risk.slice(1);
      summaryList.innerHTML='';
      adv.tips.forEach(t=>{
        const li = document.createElement('li');
        li.innerHTML = t.msg + ' <span class="tag">'+t.tag+'</span>';
        summaryList.appendChild(li);
      });
    }

    function recalc(){ const m = getModel(); draw(m); renderSummary(m); }

    // --- Events ---
    addBtn.addEventListener('click', ()=>{ newRow('',''); recalc(); });
    rowsEl.addEventListener('input', e => { if(e.target.matches('input')) recalc(); });
    rowsEl.addEventListener('click', e => { if(e.target.closest('button')){ e.target.closest('tr').remove(); recalc(); }});
    rowsEl.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && e.target.tagName==='INPUT'){
        const inputs=[...rowsEl.querySelectorAll('input')];
        const isLast = inputs.indexOf(e.target) === inputs.length-1;
        if(isLast){ newRow('', ''); setTimeout(()=>{ const inp = rowsEl.querySelector('tr:last-child input'); if(inp) inp.focus(); },0); }
      }
    });

    // Init
    seed(); recalc();

    // Keep canvas crisp on resize
    let raf; window.addEventListener('resize', ()=>{ cancelAnimationFrame(raf); raf = requestAnimationFrame(recalc); });

    // --- Basic Tests (console) ---
    (function runTests(){
      console.assert(parseAmount('10,000')===10000, 'parseAmount comma failed');
      console.assert(parseAmount('25000')===25000, 'parseAmount plain failed');
      console.assert(parseAmount('  ')===0, 'parseAmount blanks failed');
      console.assert(parseAmount('abc')===0, 'parseAmount non-numeric failed');
      try { draw({total:0, items:[]}); } catch(e){ console.error('draw(empty) threw', e); }
    })();
  </script>
</body>
</html>
