<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portfolio Concentration • Pie</title>
  <style>
    :root{ --bg:#ffffff; --ink:#0b1220; --muted:#6b7280; --ring:#e5e7eb; --accent:#2563eb; --radius:16px; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--ink)}
    .wrap{max-width:1000px;margin:24px auto;padding:12px;display:grid;gap:16px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{font-size:18px;margin:0;letter-spacing:.2px;font-weight:700}
    .card{background:#fff;border:1px solid var(--ring);border-radius:var(--radius);padding:14px;box-shadow:0 8px 24px rgba(2,6,23,.04)}
    .row{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:960px){.row{grid-template-columns:1.2fr 1fr}}
    input[type=text]{width:100%;background:#ffffff;border:1px solid #d1d5db;color:var(--ink);border-radius:12px;padding:10px 12px;outline:none;transition:border-color .15s ease}
    input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,.15)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px 8px;text-align:left}
    th{font-weight:600;color:#111827;font-size:12px;letter-spacing:.3px}
    tr{border-bottom:1px dashed #e5e7eb}
    tr:last-child{border-bottom:none}
    .mono{font-variant-numeric:tabular-nums;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ghost-btn{background:#ffffff;border:1px solid #d1d5db;color:#111827;border-radius:12px;padding:8px 10px;cursor:pointer;font-weight:600;font-size:13px}
    .ghost-btn:hover{border-color:var(--accent);color:#0b1220}
    .icon-btn{background:transparent;border:none;color:#6b7280;cursor:pointer;padding:6px;border-radius:8px}
    .icon-btn:hover{background:#f3f4f6;color:#111827}
    .muted{color:var(--muted);font-size:12px}

    /* Chart */
    .chart-col{display:grid;gap:12px}
    canvas{width:100%;height:420px;display:block}

    /* Summary */
    .summary-head{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .pill{border:1px solid var(--ring);padding:4px 8px;border-radius:999px;font-size:12px;font-weight:600}
    .pill.low{background:#ecfdf5;color:#065f46;border-color:#a7f3d0}
    .pill.balanced{background:#eff6ff;color:#1e3a8a;border-color:#bfdbfe}
    .pill.high{background:#fef2f2;color:#991b1b;border-color:#fecaca}
    .summary-list{list-style:none;margin:10px 0 0 0;padding:0;display:grid;gap:10px}
    .summary-list li{font-size:13px;color:#111827;line-height:1.35}
    .summary-list li .tag{font-size:11px;opacity:.7;margin-left:6px}
    .inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select.mini{border:1px solid var(--ring);border-radius:8px;padding:4px 8px;font-size:12px;background:#fff;color:#111827}

    /* Summary layout tweaks */
    #summaryCard{width:100%}
    #nextMove{font-size:14px; line-height:1.4; padding:6px 0}
    .summary-head h2{font-size:13px}

    /* Inline Add + Total row */
    .addbar{display:flex;align-items:center;justify-content:space-between;margin-top:10px}
    .addbar-left{display:flex;align-items:center;gap:8px}
    .totalright{display:flex;align-items:baseline;gap:8px}
    .totalright .mono{font-weight:600}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Portfolio Concentration</h1>
      <div class="muted">Enter amounts only (no %). Labels are outside with leader lines. Summary gives concrete next steps.</div>
    </header>

    <section class="card row">
      <div class="left">
        <div class="card" style="padding:0; border-radius:12px;">
          <table>
            <thead>
              <tr>
                <th style="width:60%">Category</th>
                <th style="width:30%">Amount</th>
                <th style="width:10%"></th>
              </tr>
            </thead>
            <tbody id="rows"></tbody>
          </table>
        </div>
        <div class="addbar">
          <div class="addbar-left">
            <button id="add" class="ghost-btn">+ Add Category</button>
            <div id="note" class="muted"></div>
          </div>
          <div class="totalright">
            <span class="muted">Total Portfolio</span>
            <span class="mono" id="totalOut">0</span>
          </div>
        </div>
      </div>

      <div class="chart-col">
        <canvas id="pie" width="700" height="700" aria-label="Portfolio pie chart" style="display:none"></canvas>
      </div>
    </section>

    <!-- Summary: hidden until data present; moved to full width via JS -->
    <div class="card" id="summaryCard" style="display:none">
      <div class="summary-head">
        <div class="inline">
          <h2 style="margin:0;font-size:14px">Summary</h2>
          <span id="riskPill" class="pill">—</span>
        </div>
        <div class="inline">
          <label for="policySelect" class="muted">Policy</label>
          <select id="policySelect" class="mini">
            <option value="balanced">Balanced</option>
            <option value="conservative">Conservative</option>
            <option value="growth">Growth</option>
          </select>
          <button id="detailsToggle" class="ghost-btn" style="padding:4px 8px;font-size:12px">Show details</button>
        </div>
      </div>
      <div id="nextMove" class="mono" style="margin-top:8px;color:#111827"></div>
      <div id="contribBlock" style="margin-top:8px; display:none">
        <div class="muted">New contributions (guide):</div>
        <ul id="contribList" class="summary-list"></ul>
      </div>
      <ul id="summaryList" class="summary-list" style="display:none"></ul>
      <div id="unclassified" class="summary-list" style="margin-top:6px; display:none"></div>
    </div>
  </div>

  <script>
    // --- Utilities ---
    const byId = (id) => document.getElementById(id);
    const fmt = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
    const moneyFmt = (n) => (isFinite(n) ? fmt.format(n) : "—");
    const parseAmount = (str) => {
      if (typeof str !== 'string') return 0;
      const clean = str.replace(/[\,\s]/g,'');
      const num = Number(clean);
      return isFinite(num) && num > 0 ? num : 0;
    };
    const hsl = (i,n)=>`hsl(${(i*360/Math.max(1,n))%360} 70% 50%)`;

    // --- Elements ---
    const rowsEl = byId('rows');
    const addBtn = byId('add');
    const noteEl = byId('note');
    const pie = byId('pie');
    const totalOut = byId('totalOut');
    const summaryCard = byId('summaryCard');
    const summaryList = byId('summaryList');
    const riskPill = byId('riskPill');
    const unclassifiedEl = byId('unclassified');
    const nextMoveEl = byId('nextMove');
    const policySelect = byId('policySelect');
    const contribBlock = byId('contribBlock');
    const contribList = byId('contribList');
    const detailsToggle = byId('detailsToggle');

    // Reparent summary to full width & move details button after Next move
    const sectionRow = document.querySelector('section.card.row');
    if(summaryCard && sectionRow && summaryCard.parentElement !== sectionRow.parentElement){
      sectionRow.insertAdjacentElement('afterend', summaryCard);
    }
    if(detailsToggle && nextMoveEl && detailsToggle.parentElement !== nextMoveEl.parentElement){
      nextMoveEl.insertAdjacentElement('afterend', detailsToggle);
    }

    // Persisted classification overrides and policy
    const LS_KEY_OVR = 'pc_class_overrides';
    const LS_KEY_POLICY = 'pc_policy';
    const LS_KEY_EXPANDED = 'pc_details_expanded';
    const LS_KEY_PORT = 'pc_portfolio_v1';
    let overrides = {};
    try { overrides = JSON.parse(localStorage.getItem(LS_KEY_OVR)||'{}'); } catch(_) {}
    const savedPolicy = localStorage.getItem(LS_KEY_POLICY) || 'balanced';
    policySelect.value = savedPolicy;
    let expanded = (localStorage.getItem(LS_KEY_EXPANDED) === '1');
    function syncDetailsToggle(){ if(detailsToggle) detailsToggle.textContent = expanded ? 'Hide details' : 'Show details'; }
    syncDetailsToggle();

    // --- Rows ---
    function newRow(category='', value=''){
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td><input type="text" placeholder="e.g., Stocks" value="${category}"/></td>
        <td><input type="text" class="mono" placeholder="e.g., 50000" value="${value}"/></td>
        <td style="text-align:right"><button class="icon-btn" title="Remove" aria-label="Remove">✕</button></td>`;
      rowsEl.appendChild(tr);
    }
    function seed(){ newRow('Stocks',''); newRow('Real Estate',''); newRow('Cash',''); newRow('Crypto',''); }

    function getModel(){
      const items=[];
      [...rowsEl.querySelectorAll('tr')].forEach((tr,idx)=>{
        const name = tr.querySelector('td:nth-child(1) input').value.trim() || `Category ${idx+1}`;
        const raw  = tr.querySelector('td:nth-child(2) input').value;
        const amount = parseAmount(raw);
        if(amount>0) items.push({name,amount});
      });
      const total = items.reduce((a,b)=>a+b.amount,0);
      return { total, items };
    }

    // --- Persistence ---
    function savePortfolio(model){
      try {
        const data = Array.isArray(model?.items) ? model.items : [];
        localStorage.setItem(LS_KEY_PORT, JSON.stringify(data));
      } catch(_) {}
    }
    function loadPortfolio(){
      try {
        const raw = localStorage.getItem(LS_KEY_PORT);
        const data = raw ? JSON.parse(raw) : [];
        if(Array.isArray(data) && data.length>0){
          rowsEl.innerHTML='';
          data.forEach(it=> newRow(it.name || '', String(it.amount || '')));
          return true;
        }
      } catch(_) {}
      return false;
    }

    // --- Chart with outside labels & collision avoidance ---
    function draw(model){
      const ctx = pie.getContext('2d');
      const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const W = pie.clientWidth * DPR, H = pie.clientHeight * DPR;
      if(pie.width!==W) pie.width=W; if(pie.height!==H) pie.height=H;
      ctx.clearRect(0,0,W,H); ctx.save();

      const {items,total:sum} = model;
      totalOut.textContent = moneyFmt(sum);

      if(sum<=0){
        pie.style.display='none';
        ctx.restore();
        if(summaryCard) summaryCard.style.display='none';
        if(nextMoveEl) nextMoveEl.textContent='';
        return;
      }

      pie.style.display='block';

      const pad = Math.min(W,H)*0.08;
      const cx = W/2, cy = H/2;
      const radius = Math.max(40, Math.min(W,H)*0.40 - pad);
      const inner  = radius * 0.55;

      const dividerColor = 'rgba(255,255,255,0.95)';
      const labelColor   = '#111827';

      // --- First pass: draw slices and collect label targets
      let start = -Math.PI/2;
      const labels = [];
      items.forEach((it,i)=>{
        const frac = it.amount / sum;
        const end = start + frac*Math.PI*2;

        // slice (donut)
        ctx.beginPath();
        ctx.arc(cx, cy, radius, start, end);
        ctx.arc(cx, cy, inner, end, start, true);
        ctx.closePath();
        ctx.fillStyle = hsl(i, items.length);
        ctx.fill();

        // divider
        ctx.lineWidth = Math.max(1, Math.min(W,H)*0.004);
        ctx.strokeStyle = dividerColor;
        ctx.stroke();

        // label anchor just outside arc
        const mid = (start+end)/2;
        const baseR = radius + 22; // where text baseline aims
        const lx = cx + Math.cos(mid) * baseR;
        const ly = cy + Math.sin(mid) * baseR;
        const side = (mid>Math.PI/2 || mid<-Math.PI/2) ? 'left' : 'right';
        const text = `${it.name} · ${(frac*100).toFixed(frac<0.1?1:0)}%`;
        const angle = mid; // keep for sorting
        labels.push({x:lx,y:ly,side,text,angle,frac});

        start = end;
      });

      // --- Second pass: simple collision avoidance per side ---
      const minGap = Math.max(12, Math.min(W,H)*0.03); // minimum vertical gap between labels
      function relax(side){
        const arr = labels.filter(l=>l.side===side).sort((a,b)=>a.y-b.y);
        for(let i=1;i<arr.length;i++){
          if(arr[i].y - arr[i-1].y < minGap){
            arr[i].y = arr[i-1].y + minGap;
          }
        }
        const topBound = cy - (radius + 70);
        const botBound = cy + (radius + 70);
        if(arr.length){
          if(arr[0].y < topBound){
            const delta = topBound - arr[0].y;
            for(const l of arr) l.y += delta;
          }
          if(arr[arr.length-1].y > botBound){
            const delta = arr[arr.length-1].y - botBound;
            for(const l of arr) l.y -= delta;
          }
        }
      }
      relax('left');
      relax('right');

      // --- Draw leaders and labels ---
      ctx.font = `${Math.max(11,Math.min(W,H)*0.025)}px ui-sans-serif, system-ui`;
      ctx.textBaseline = 'middle';
      ctx.fillStyle = labelColor;
      labels.forEach(l=>{
        const alignRight = l.side==='left';
        ctx.textAlign = alignRight ? 'right' : 'left';
        const textX = l.x + (alignRight ? -6 : 6);
        const textY = l.y;

        const arcPointX = cx + Math.cos(l.angle) * radius;
        const arcPointY = cy + Math.sin(l.angle) * radius;
        const midX = cx + Math.cos(l.angle) * (radius + 10);
        const midY = cy + Math.sin(l.angle) * (radius + 10);
        const endX = textX + (alignRight ? 4 : -4);

        ctx.beginPath();
        ctx.moveTo(arcPointX, arcPointY);
        ctx.lineTo(midX, midY);
        ctx.lineTo(endX, textY);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.stroke();

        ctx.fillText(l.text, textX, textY);
      });

      // center total label
      ctx.fillStyle = '#111827';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.max(12,Math.min(W,H)*0.035)}px ui-sans-serif, system-ui`;
      ctx.fillText(`Total ${moneyFmt(sum)}`, cx, cy);

      ctx.restore();
    }

    // --- Policy targets ---
    function getTargets(policy){
      // percentages that sum to 100
      if(policy==='conservative') return {stocks:40,bonds:40,cash:15,real_estate:3,commodities:1,crypto:1,other:0};
      if(policy==='growth') return {stocks:70,bonds:15,cash:7,real_estate:4,commodities:2,crypto:2,other:0};
      return {stocks:55,bonds:25,cash:10,real_estate:5,commodities:3,crypto:2,other:0}; // balanced
    }

    // --- Summary/advice logic ---
    function baseClassify(name){
      const n = name.toLowerCase();
      if(/bond|fixed|income|treasury|t-bill|gilts|muni/.test(n)) return 'bonds';
      if(/stock|equit|etf|fund|index|voo|qqq|schd|s&p|nasdaq|pe|private\s*equity|venture|angel|startup/.test(n)) return 'stocks';
      if(/real\s*estate|property|reit|house|apartment|land/.test(n)) return 'real_estate';
      if(/cash|savings|deposit|money\s*market|t\s*-?bill|mmf/.test(n)) return 'cash';
      if(/crypto|bitcoin|btc|eth|sol|token|defi/.test(n)) return 'crypto';
      if(/gold|silver|metal|commodity|oil|energy|wti|brent/.test(n)) return 'commodities';
      return 'other';
    }
    function classify(name){
      const key = name.toLowerCase();
      if(overrides[key]) return overrides[key];
      return baseClassify(name);
    }

    function analyze(model){
      const total = model.total || 0;
      const buckets = {stocks:0,bonds:0,cash:0,real_estate:0,crypto:0,commodities:0,other:0};
      const byBucket = {stocks:[],bonds:[],cash:[],real_estate:[],crypto:[],commodities:[],other:[]};
      model.items.forEach(it=>{ const k = classify(it.name); buckets[k]+=it.amount; byBucket[k].push(it); });

      const pct = k => total>0 ? (buckets[k]||0)/total : 0;
      const p = Object.fromEntries(Object.keys(buckets).map(k=>[k,pct(k)]));

      // Risk heuristic
      let risk = 'balanced';
      const growth = p.stocks + p.crypto + p.commodities*0.5;
      const defense = p.bonds + p.cash + p.real_estate*0.2;
      if(growth >= 0.7 || p.crypto >= 0.12) risk = 'high';
      else if(defense >= 0.45 || p.bonds >= 0.35) risk = 'low';

      return { total, buckets, p, byBucket, risk };
    }

    function buildActions(analysis, policy){
      const targetsPct = getTargets(policy); // in %
      const total = analysis.total;
      const actions = [];

      // deltas (percentage points) current minus target
      const deltas = {};
      for(const k in targetsPct){
        const targetF = (targetsPct[k]||0)/100;
        deltas[k] = (analysis.p[k]||0) - targetF;
      }

      // overweight / underweight lists
      const overweight = Object.keys(deltas).filter(k=>deltas[k]>0.001).sort((a,b)=>deltas[b]-deltas[a]);
      const underweight = Object.keys(deltas).filter(k=>deltas[k]<-0.001).sort((a,b)=>deltas[a]-deltas[b]);

      // concrete shift plan between existing buckets
      let plan = null;
      if(overweight.length && underweight.length){
        const src = overweight[0], dst = underweight[0];
        const moveFrac = Math.min(deltas[src], -deltas[dst]);
        const moveAmt = Math.round(moveFrac * total);
        plan = {src,dst,amount:moveAmt};
      }

      const tol = 0.03; // 3 percentage points tolerance
      for(const k of Object.keys(deltas)){
        const diff = deltas[k];
        if(Math.abs(diff) < tol) continue;
        const dir = diff>0 ? 'Reduce' : 'Increase';
        const pp = Math.abs(diff*100).toFixed(1);
        const amt = Math.round(Math.abs(diff) * total);
        const target = targetsPct[k];
        const msg = `${dir} ${labelFor(k)} by ${pp} pp to reach ${target}% target.`;
        actions.push({msg, tag:'rebalance', k, dir, pp, amt});
      }

      // New contributions plan: allocate proportionally to deficits
      const deficits = {};
      let deficitSum = 0;
      for(const k in targetsPct){
        const targetF = (targetsPct[k]||0)/100;
        const def = Math.max(0, targetF - (analysis.p[k]||0));
        deficits[k] = def; deficitSum += def;
      }
      let contrib = [];
      if(deficitSum > 0){
        for(const k in deficits){
          if(deficits[k] > 0){
            const share = deficits[k] / deficitSum;
            contrib.push({k, share});
          }
        }
        contrib.sort((a,b)=>b.share - a.share);
      }
      const topDst = contrib.length ? contrib[0].k : (underweight[0] || null);

      return {actions, plan, contrib, topDst, targetsPct};
    }

    function labelFor(k){
      return k.replace('_',' ').replace(/\b\w/g, c=>c.toUpperCase());
    }

    function renderSummary(model){
      if(!summaryCard) return;
      if(!model.total){ summaryCard.style.display='none'; return; }
      summaryCard.style.display='block';

      const policy = policySelect.value;
      const a = analyze(model);
      riskPill.className = 'pill ' + a.risk;
      riskPill.textContent = 'Risk: ' + (a.risk.charAt(0).toUpperCase() + a.risk.slice(1));
      riskPill.title = 'Overall risk posture based on current mix';

      const {actions, plan, contrib, topDst, targetsPct} = buildActions(a, policy);

      // Next move only (always shown)
      const parts = [];
      if(plan){ parts.push(`shift ~ ${moneyFmt(plan.amount)} from ${labelFor(plan.src)} → ${labelFor(plan.dst)}`); }
      if(topDst){ const tgt = targetsPct[topDst] ?? 0; parts.push(`direct new contributions to ${labelFor(topDst)} until ~${tgt}%`); }
      if(parts.length===2){ nextMoveEl.textContent = `Next move: EITHER ${parts[0]} OR ${parts[1]}.`; }
      else if(parts.length===1){ nextMoveEl.textContent = `Next move: ${parts[0]}.`; }
      else { nextMoveEl.textContent = 'Next move: minor drift — rebalancing not urgent.'; }

      // If collapsed: hide details and exit
      if(!expanded){
        if(summaryList){ summaryList.style.display='none'; summaryList.innerHTML=''; }
        if(contribBlock){ contribBlock.style.display='none'; }
        if(unclassifiedEl){ unclassifiedEl.style.display='none'; unclassifiedEl.innerHTML=''; }
        return;
      }

      // Expanded: show details
      if(summaryList) summaryList.style.display='grid';
      if(unclassifiedEl) unclassifiedEl.style.display='grid';

      // Action list
      summaryList.innerHTML='';
      if(actions.length===0){
        const li = document.createElement('li');
        li.textContent = 'You are within target bands. Maintain contributions and rebalance annually.';
        summaryList.appendChild(li);
      } else {
        actions.forEach(t=>{ const li=document.createElement('li'); li.innerHTML = t.msg + ' <span class="tag">'+t.tag+'</span>'; summaryList.appendChild(li); });
      }

      // Contributions guidance
      if(contrib && contrib.length){
        contribBlock.style.display = 'block';
        contribList.innerHTML = '';
        const guideAmt = Math.max(1000, Math.round(a.total * 0.05)); // suggest 5% of portfolio (min 1k)
        const show = contrib.slice(0,5);
        show.forEach(c=>{
          const li = document.createElement('li');
          const pct = (c.share*100).toFixed(c.share<0.1?1:0);
          li.textContent = `${labelFor(c.k)} — ${pct}% of next contributions`;
          contribList.appendChild(li);
        });
        if(contrib.length > 5){
          const rest = contrib.slice(5).reduce((s,c)=>s+c.share,0);
          const li = document.createElement('li');
          li.textContent = `Others — ${(rest*100).toFixed(0)}%`;
          contribList.appendChild(li);
        }
      } else {
        contribBlock.style.display = 'none';
      }

      // Unclassified categories with live classifier
      const unknownItems = a.byBucket.other || [];
      unclassifiedEl.innerHTML = '';
      if(unknownItems.length){
        const title = document.createElement('li');
        title.innerHTML = '<strong>Classify new categories</strong> (choose the closest risk bucket)';
        unclassifiedEl.appendChild(title);
        unknownItems.forEach(it=>{
          const li = document.createElement('li');
          const key = it.name.toLowerCase();
          const current = (overrides||{})[key] || 'other';
          li.innerHTML = `
            <div class="inline">
              <span class="mono">${it.name}</span>
              <select data-name="${it.name}" class="mini">
                <option value="stocks" ${current==='stocks'?'selected':''}>Equities</option>
                <option value="bonds" ${current==='bonds'?'selected':''}>Bonds</option>
                <option value="cash" ${current==='cash'?'selected':''}>Cash</option>
                <option value="real_estate" ${current==='real_estate'?'selected':''}>Real Estate</option>
                <option value="commodities" ${current==='commodities'?'selected':''}>Commodities</option>
                <option value="crypto" ${current==='crypto'?'selected':''}>Crypto</option>
                <option value="other" ${current==='other'?'selected':''}>Other</option>
              </select>
            </div>`;
          unclassifiedEl.appendChild(li);
        });
      }
    }

    function recalc(){
      const m = getModel();
      draw(m);
      renderSummary(m);
      savePortfolio(m);
    }

    // --- Events ---
    addBtn.addEventListener('click', ()=>{ newRow('',''); recalc(); });
    rowsEl.addEventListener('input', e => { if(e.target.matches('input')) recalc(); });
    rowsEl.addEventListener('click', e => { if(e.target.closest('button')){ e.target.closest('tr').remove(); recalc(); }});
    rowsEl.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && e.target.tagName==='INPUT'){
        const inputs=[...rowsEl.querySelectorAll('input')];
        const isLast = inputs.indexOf(e.target) === inputs.length-1;
        if(isLast){ newRow('', ''); setTimeout(()=>{ const inp = rowsEl.querySelector('tr:last-child input'); if(inp) inp.focus(); },0); }
      }
    });

    // Handle classification changes & policy select & details toggle
    unclassifiedEl.addEventListener('change', (e)=>{
      const sel = e.target.closest('select');
      if(!sel) return;
      const name = sel.getAttribute('data-name');
      if(!name) return;
      overrides[name.toLowerCase()] = sel.value;
      try { localStorage.setItem(LS_KEY_OVR, JSON.stringify(overrides)); } catch(_) {}
      recalc();
    });
    policySelect.addEventListener('change', ()=>{ localStorage.setItem(LS_KEY_POLICY, policySelect.value); recalc(); });
    if(detailsToggle){
      detailsToggle.addEventListener('click', ()=>{
        expanded = !expanded;
        localStorage.setItem(LS_KEY_EXPANDED, expanded ? '1' : '0');
        syncDetailsToggle();
        renderSummary(getModel());
      });
    }

    // Init
    if(!loadPortfolio()) { seed(); }
    recalc();

    // Keep canvas crisp on resize
    let raf; window.addEventListener('resize', ()=>{ cancelAnimationFrame(raf); raf = requestAnimationFrame(recalc); });

    // --- Basic Tests (console) ---
    (function runTests(){
      // parseAmount
      console.assert(parseAmount('10,000')===10000, 'parseAmount comma failed');
      console.assert(parseAmount('25000')===25000, 'parseAmount plain failed');
      console.assert(parseAmount('  ')===0, 'parseAmount blanks failed');
      console.assert(parseAmount('abc')===0, 'parseAmount non-numeric failed');
      console.assert(parseAmount('-100')===0, 'parseAmount negative should be 0');

      // targets sum to 100
      const sumBal = Object.values(getTargets('balanced')).reduce((a,b)=>a+b,0);
      const sumCons = Object.values(getTargets('conservative')).reduce((a,b)=>a+b,0);
      const sumGrow = Object.values(getTargets('growth')).reduce((a,b)=>a+b,0);
      console.assert(sumBal===100 && sumCons===100 && sumGrow===100, 'policy targets must sum to 100');

      // analyze & buildActions
      const demo = { total: 100000, items: [
        {name:'Stocks',amount:60000},
        {name:'Bonds',amount:15000},
        {name:'Cash',amount:5000},
        {name:'Real Estate',amount:15000},
        {name:'Crypto',amount:5000}
      ]};
      const a = analyze(demo);
      console.assert(a && a.total===100000, 'analyze total mismatch');
      const b = buildActions(a,'balanced');
      console.assert(b && Array.isArray(b.actions), 'buildActions should return actions');
      console.assert('topDst' in b, 'buildActions should include topDst');

      // draw safety on empty, and with many slices
      try { draw({total:0, items:[]}); } catch(e){ console.error('draw(empty) threw', e); }
      try {
        const many = { total: 100000, items: Array.from({length:10}, (_,i)=>({name:'Cat '+(i+1), amount: 10000})) };
        draw(many);
      } catch(e){ console.error('draw(many) threw', e); }

      // renderSummary smoke test (uses demo data)
      try { renderSummary({ total: demo.total, items: demo.items }); } catch(e){ console.error('renderSummary threw', e); }

      // gating tests
      try {
        draw({total:0, items:[]});
        console.assert(pie.style.display==='none', 'pie should be hidden when empty');
        console.assert(summaryCard.style.display==='none', 'summary should be hidden when empty');
        const m2 = { total: 100, items: [{name:'Stocks', amount:100}]};
        draw(m2);
        console.assert(pie.style.display==='block', 'pie should show when data present');
        renderSummary(m2);
        console.assert(summaryCard.style.display==='block', 'summary should show when data present');
      } catch(e){ console.error('gating tests error', e); }

      // persistence tests (non-destructive)
      try {
        const prev = localStorage.getItem(LS_KEY_PORT);
        const probe = [{name:'Test Persist', amount:12345}];
        localStorage.setItem(LS_KEY_PORT, JSON.stringify(probe));
        const round = JSON.parse(localStorage.getItem(LS_KEY_PORT)||'[]');
        console.assert(Array.isArray(round) && round[0] && round[0].amount===12345, 'portfolio save/load failed');
        // restore
        if(prev===null) localStorage.removeItem(LS_KEY_PORT); else localStorage.setItem(LS_KEY_PORT, prev);
      } catch(e){ console.error('persistence test failed', e); }

      // IMPORTANT: restore real UI to initial hidden state after tests
      try { recalc(); } catch(e){ console.error('restore state failed', e); }
    })();
  </script>
</body>
</html>
